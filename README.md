Здесь находятся скрипты, которые готовят документы корпуса для индексирования в Яндекс.SaaS, а также обрабатывают ответ поискового источника.

Предполагается, что исходные документы поступают в формате XML уже с морфологической и семантической разметкой. Скрипт xml2json.py преобразует их во внутреннее представление (которое хорошо ложится на формат JSON). В этом представлении документ (Doc) делится на части (Part), такие, что ожидаемые сниппеты всегда целиком лежат внутри части. Части делятся на предложения (Sent), предложения - на слова (Word). Слова могут иметь один или несколько разборов (Ana). У каждого элемента этой иерархии могут быть свои атрибуты (Attrs), которые представляют из себя словари вида "ключ - список значений".


Документы в этом формате пропускаются через специальные обработчики, которые обогащают разметку (например, проставляют у слов теги, связанные с наличием вокруг слов знаков препинания, с повтором тех или иных грамматических категорий, с позицией слова внутри предложения, наличием заглавной буквы и т. д.).


По ряду причин в SaaS документ поставляется тоже в формате XML. Точнее, в SaaS уходит multipart-запрос на индексацию с особым JSON, к которому прикрепляется XML с телом размеченного документа. В JSON-запросе описываются метаатрибуты этого документа, а также свойства (properties) - прикрепленные к документу данные (любой природы), которые будут отданы поиском, если документ будет найден. В таких свойствах мы храним "прямой" индекс - упакованную исходную JSON-структуру части документа, которая позволяет построить контекст найденных слов и узнать, какие атрибуты были приписаны словам в этом контексте. Упаковка производится через сжатие с помощью zlib и кодирование в base64.


Скрипты поиска server.py и search.py (front end, если угодно), получают с запрос пользователя с морды (http://ruscorpora.ru/beta/search-saas.html), формируют на его основе внутренний запрос к SaaS, получают ответ в формате protobuf (какие документы найдены + координаты хитов в этих документах + свойства, т. е., прямые индексы этих документов), составляют на его основе ответ со сниппетами. Далее этот ответ превращается в XML старого формата и верстается в HTML старой технологией на основе XSLT. Хочется в этом месте верстать HTML каким-либо шаблонизатором напрямую.


Атрибуты в SaaS'е.

Классификация атрибутов по типу данных:
1. Целочисленные (ui64). (на самом деле ui63)
2. Литеральные.

Классификация по области действия:
1. Документные (aka метаатрибуты).
2. Зонные (приписанные предложению, слову и т. д.)

Классификация документных атрибутов по назначению:
1. Поисковые (по ним можно задавать запросы). Могут быть как документными, так и зонными.
2. Группировочные (по ним можно группировать найденные документы или сортировать, могут быть только целочисленными). Только документные.
3. Свойства (просто выдаются по требованию вместе с найденным документом). Только документные.


При индексации мы передаем в SaaS две сущности:
1. Управляющий JSON с инструкциями, что надо делать, и как выглядит наш документ. Сюда же можно вставить и метаатрибуты.
2. Сам документ в формате XML. Здесь все зонные атрибуты будут описаны как XML-атрибуты тегов. 

Описание метаатрибутов в управляющем JSON'е.
Выглядит примерно так: "s_url": {"value": url, "type": "#hl"}.
Коды типов атрибутов (type):
#i - поисковый целочисленный атрибут
#l - поисковый литеральный атрибут
#g - группировочный целочисленный атрибут
#h - группировочный литеральный атрибут (вместо исходного значения в реальности будет содержать ui64-хеш от него)
#p - свойство (можно комбинировать с i и l)

Описание зонных атрибутов в индексируемом XML-документе.
Тут действует простое соглашение: если имя атрибута начинается с префикса "sz_", то это - литеральный атрибут.
Если с "iz_" - целочисленный (но такие зонные атрибуты у нас вроде бы не встречаются).



PREREQUISITES
sudo apt-get install python-dev
sudo pip install python-cjson
sudo pip install requests

wget https://github.com/mll/ctemplate-python/archive/master.zip
unzip master.zip
cd ctemplate-python-master
sudo python setup.py install


1. /place/ruscorpora/corpora/accent/accent_main --> /place/ruscorpora/texts/finalized/accent/accent_main
2. /place/ruscorpora/corpora/accent/accent_stihi --> /place/ruscorpora/texts/finalized/accent/accent_stihi
3. /place/ruscorpora/corpora/poetic/ --> /place/ruscorpora/texts/finalized/accent/accent_poetic

clear && sudo python index.py --index --dir /place/ruscorpora/texts/finalized/accent_main/ --kps 66 --corpus_type accent --subcorpus accent --nodisk
clear && sudo python index.py --index --dir /place/ruscorpora/texts/finalized/accent_stihi/ --kps 66 --corpus_type accent_stihi --subcorpus poetic --nodisk
clear && sudo python index.py --index --dir /place/ruscorpora/texts/finalized/accent_poetic/ --kps 66 --corpus_type accent_poetic --subcorpus poetic --nodisk







clear && sudo python index.py --index --dir /place/ruscorpora/texts/finalized/spoken/ --kps 74 --corpus_type spoken_spoken --subcorpus spoken --meta
clear && sudo python index.py --index --dir /place/ruscorpora/texts/finalized/spoken/spoken/ --kps 74 --corpus_type spoken_spoken --subcorpus spoken --nodisk
clear && sudo python index.py --index --dir /place/ruscorpora/texts/finalized/spoken/accent_main/ --kps 74 --corpus_type spoken_accent --subcorpus accent --nodisk









python delete.py 74 ALL